'use strict';

// Node JS global scope
var fs = global.fs = global.fs || require('fs');
var gulp = global.gulp = global.gulp || require('gulp');
var common = global.config = global.config || require('../utils/common.js');
var runSequence = global.runSequence = global.runSequence || require('run-sequence');
var shelljs = require('shelljs');

var config = common.config();

function compileTSFiles(tsConfigs, gulpObj, tsConfigPath, done) {
    var ts = require('gulp-typescript');
    // Default typescript config
    var defaultConfig = {
        typescript: require('typescript')
    };

    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; ++i) {
        args[i] = arguments[i];
    }

    tsConfigs = args.shift();
    gulpObj = args.shift();
    done = args.pop();

    tsConfigPath = args.length ? args.shift() : 'tsconfig.json';

    var tsProject, tsResult;

    function refreshValue(flag) {
        // Create the typescript project
        tsProject = ts.createProject(tsConfigPath, Object.assign((flag ? { removeComments: false } : {}), defaultConfig, tsConfigs));
        // Get typescript result
        tsResult = gulp.src(gulpObj.src, { base: gulpObj.base })
            .pipe(ts(tsProject))
            .on('error', function (e) {
                fs.appendFileSync('./gulp_error.log', 'Failed scripts-gen task \ndetails/n' + e);
                done(e);
                process.exit(1);
            });
    }

    // Compile d.ts and minified files
    if (gulpObj.needDts) {
        refreshValue(true);
        tsResult.dts.pipe(gulp.dest(gulpObj.dest));
    }
    refreshValue();
    // Combine and uglify js files using webpack

    if (gulpObj.hasOwnProperty('combine')) {
        var webpackStream = require('webpack-stream');
        var webpack = require('webpack');
        tsResult.js.pipe(webpackStream({
            output: {
                filename: `${common.currentPackage}${gulpObj.combine ? '.umd.min.js' : '.umd.js'}`,
                libraryTarget: 'umd'
            },
            externals: (gulpObj.externals || []),
            plugins: gulpObj.combine ? [
                new webpack.optimize.UglifyJsPlugin()
            ] : [],
            devtool: gulpObj.combine ? '' : 'inline-source-map',
        })).pipe(gulp.dest(gulpObj.dest))
            .on('end', function () {
                done();
            });
    }
    // Compile normal js files without uglification
    else {
        tsResult.js.pipe(gulp.dest(gulpObj.dest))
            .on('end', function () {
                done();
            });

    }
}
exports.compileTSFiles = compileTSFiles;

// Generate root files manually.
gulp.task('generate-root-files',function(done){
    generateRootFiles('./src');
    done();
});
/** 
 * Compile TypeScript to JS
 */
var isValidRepo = (common.currentRepo !== 'ej2' && common.currentRepo !== 'ej2-samples' && common.currentRepo !== 'ej2-react-samples');
var preScript = !isValidRepo ? [] : ['execute-generator'];
gulp.task('scripts-gen', function (done) {
    var isRemote = process.env.GithubBuildAutomation_PrivateToken || global.isLocal;
    var gulpObj = {
        src: config.ts,
        dest: './',
        base: '.',
        needDts: isRemote ? true : false
    };
    if (isRemote && isValidRepo) {
        generateRootFiles('./src');
    }
    return compileTSFiles({}, gulpObj, done);
});

// TS Script Generation with Execute Generator
gulp.task('scripts', preScript, function (done) {
    runSequence(common.currentRepo === 'ej2-es-build' ? 'scripts-gen' : ['hide-license', 'scripts-gen'], done);
});

//builders  execution
gulp.task('execute-generator', function (done) {
    runSequence('create-model', 'typedoc', done);
});

// Create common root files 
function generateRootFiles(source) {
    var path = require('path');
    var files = fs.readdirSync(source);
    for (var i = 0; i < files.length; i++) {
        var pathObj = path.parse(files[i]);
        var file = path.join(source, files[i]);
        var stat = fs.lstatSync(file);
        if ((stat.isDirectory()) || (pathObj.name === 'index' && pathObj.ext === '.ts')) {
            var name = pathObj.name === 'index' ? pathObj.name : pathObj.name + '/index';
            var content = getCommentLine(pathObj.name) + 'export * from \'' + source + '/' + name + '\';';
            fs.writeFileSync('./' + pathObj.name + '.ts', content);
        }
    }
    return;
}
exports.generateRootFiles = generateRootFiles;

// Generate comment line
function getCommentLine(description) {
    return '/**\n' + ' * ' + description + '\n */\n';
}
exports.getCommentLine = getCommentLine;

/**
 * Bundle all module using webpack
 */
gulp.task('bundle', function (done) {
    // require files    
    var webpackUtil = require('../utils/webpack');
    var webpackConfig = require(fs.realpathSync('./webpack.config.js'));
    return webpackUtil.bundleWebpack(webpackConfig, done);
});

/** 
 * Generate Model definition file.
 */
gulp.task('create-model', function () {
    var modelGen = require('../generators/model.js');
    return gulp.src(config.createmodel)
        .pipe(modelGen());
});

/**
 * Compile default theme
 */
gulp.task('styles', function (done) {
    runSequence('default-theme', 'compile-styles', done);
});

/**
 * Compile all themes
 */
gulp.task('styles-all', function (done) {
    runSequence('all-themes', 'compile-styles','offline-theme', done);
});

/** 
 * Compile scss to css
 */
var isCompiled = true;
gulp.task('compile-styles', function () {
    var gutil = require('gulp-util');
    var sass = require('gulp-sass');
    sass.compiler = require('sass');
    var autoPrefixer = require('gulp-autoprefixer');
    return gulp.src(config.styles, { base: './' })
        .pipe(sass({
            outputStyle: common.currentRepo === 'ej2' ? 'compressed' : 'expanded',
            includePaths: config.node_modules
        }).on('error', function (error) {
            isCompiled = false;
            fs.appendFileSync('./gulp_error.log','Failed compile-styles task \ndetails/n' + error);
            gutil.log(new gutil.PluginError('sass', error.messageFormatted).toString());
            this.emit('end');
        }))
        .pipe(autoPrefixer({ browsers: ['last 2 versions', 'ie >= 11'] }))
        .pipe(gulp.dest('.'))
        .on('end', function () {
            if (!isCompiled) {
                process.exit(1);
            }
        });
});

/**
 * Generate tailwind theme files
 */
gulp.task ('tailwind-theme', function() {
    runSequence('tailwind-generate', 'compile-styles');
});

gulp.task('tailwind-generate', function () {
    var tailwindTheme = ['tailwind', 'tailwind-dark'];
    var themes = require('../generators/themes.js');
    return themes.generateThemes(tailwindTheme);
});

/**
 * Generate Bootstrap5 theme files
 */
 gulp.task ('bootstrap5-theme', function() {
    runSequence('bootstrap5-generate', 'compile-styles');
});

gulp.task('bootstrap5-generate', function () {
    var bootstrap5Theme = ['bootstrap5'];
    var themes = require('../generators/themes.js');
    var b5Variables = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
    b5Variables.themes.push('bootstrap5');
    var b5Theme = JSON.stringify(b5Variables);
    for (var i = 0; i < b5Variables.components.length; i++) {
        if(fs.existsSync('./styles/' + b5Variables.components[i] + '/_bootstrap5-definition.scss')) {
            if (b5Variables.themes.indexOf('bootstrap5') !== -1) {
                fs.writeFileSync('./config.json', b5Theme);
            }
        }
    }
    return themes.generateThemes(bootstrap5Theme);
});


/**
 * Generate default theme files
 */
gulp.task('default-theme', function () {
    var themes = require('../generators/themes.js');
    return themes.generateThemes([config.defaultTheme]);
});

/**
 * Generate all theme files
 */
gulp.task('all-themes', function () {
    config.themes = [
        'material',
        'fabric',
        'bootstrap',
        'highcontrast',
        'material-dark',
        'fabric-dark',
        'bootstrap-dark',
        'highcontrast-light',
        'bootstrap4',
        'bootstrap5',
        'bootstrap5-dark',
        'tailwind',
        'tailwind-dark',
        'fluent',
        'fluent-dark',
        'material3',
        'material3-dark'
    ];
    var themes = require('../generators/themes.js');
    return themes.generateThemes(config.themes);
});

/**
 * detect duplicate codes
 */
gulp.task('dedupe', function () {
    // var jscpd = require('gulp-jscpd');
    // var source = config.dedupe;
    // if (common.currentRepo === 'ej2-build-tasks') {
    //     source = ['./src/**/*.js', './spec/**/*.js', '!./src/**/blazor.js',
    //         '!./src/third-party/blazor/src-generator.js', '!./src/third-party/asp-core/src-generator.js',
    //         '!./src/third-party/shared/property-reader.js', '!./src/third-party/vue/property-reader.js',
    //         '!./src/third-party/blazor/property-reader.js'
    //     ];
    // }
    // return gulp.src(source)
    //     .pipe(jscpd({
    //         verbose: true
    //     }));
});

gulp.task('add-config', function() {
    var addThemes = ['fluent', 'fluent-dark', 'material3', 'material3-dark'];
    var themeVariables = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
    if((themeVariables.components) && (fs.existsSync('./styles/'))) {
        for (var i = 0; i < themeVariables.components.length; i++) {
            for(var j=0; j < addThemes.length; j++) {
                if(fs.existsSync('./styles/' + themeVariables.components[i] + '/_' + addThemes[j] + '-definition.scss') || addThemes[j].indexOf('-dark') !== -1) {
                    if (themeVariables.themes.indexOf(addThemes[j]) === -1) {
                        themeVariables.themes.push(addThemes[j]);
                        var addTheme = JSON.stringify(themeVariables);
                        fs.writeFileSync('./config.json', addTheme);
                    }
                }
            }
        }
    }
});

/**
 * Run build task.
 */
gulp.task('build', function (done) {
    shelljs.exec('gulp update-themes');
    shelljs.exec('gulp copy-themes');
    var b5Variables = JSON.parse(fs.readFileSync('./config.json', 'utf8'));
    if (b5Variables.components) {
        for (var i = 0; i < b5Variables.components.length; i++) {
            if(fs.existsSync('./styles/' + b5Variables.components[i] + '/_bootstrap5-definition.scss')) {
                if (b5Variables.themes.indexOf('bootstrap5-dark') === -1) {
                    b5Variables.themes.push('bootstrap5-dark');
                    var b5Theme = JSON.stringify(b5Variables);
                    fs.writeFileSync('./config.json', b5Theme);
                }
            }
        }
    }
    runSequence('add-config', 'styles-all', 'scripts', done);
});
//Remove robotic Link
gulp.task('customize', function (done) {

    if (common.currentRepo === 'ej2-base-library') {
        if (fs.existsSync('./styles/customize')) {

            customizeTask();
        }
        else {
            fs.mkdirSync('./styles/customize');
            customizeTask();
        }

    }

    done();

});

//Remove robotic Link
gulp.task('offline-theme', function (done) {

    var customPath = ['tailwind.css', 'tailwind-dark.css', 'material.css', 'material-dark.css'];

    if (common.currentRepo === 'ej2-base-library') {

        try {
            if(!fs.existsSync('./styles/offline-theme'))
            {
            fs.mkdirSync('./styles/offline-theme');
             }
            if (fs.existsSync('./styles/offline-theme')) {
                for (var i = 0; i < customPath.length; i++) {
                     var content = fs.readFileSync('./styles/' + customPath[i], 'utf-8');
                     if (customPath[i] === 'tailwind.css' || customPath[i] === 'tailwind-dark.css') {
                        content = content.replace('@import url("https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap");', '');
                       }
                    else {
                        content = content.replace('@import url("https://fonts.googleapis.com/css?family=Roboto:400,500");', '');
                    }

                    fs.writeFileSync('./styles/offline-theme/' + customPath[i], content);
                }

            }
        }

        catch (e) {
            fs.appendFileSync('./gulp_error.log', 'Failed offline-theme task \ndetails/n' + e);
            console.log(e);
        }
    }

    done();
});

// React build task.
gulp.task('es-build', function (done) {
    runSequence('styles-all', 'create-model', 'scripts-gen', done);
});

// Install log task.
gulp.task('ls-log', function () {
    shelljs.mkdir('-p', './cireports/logs');
    shelljs.exec('npm ls >./cireports/logs/install.log');
});

gulp.task('update-themes', function (done) {
    var compName = JSON.parse(fs.readFileSync('./package.json', 'utf8')).name.replace('@syncfusion/ej2-', '');
    var themejson = require(__dirname + '/theme.json');
    if (__dirname.indexOf('/third-party/') === -1 && !fs.existsSync('./themestudio')) {
        if (themejson[compName]) {
            themecheckout(done);
        }
    } else {
        console.log('Themes not cloned for thirdparty');
        done();
    }
});

gulp.task('copy-themes', function (done) {
var shelljs = global.shelljs = global.shelljs || require('shelljs');
if (__dirname.indexOf('/third-party/') === -1) {
    if (fs.existsSync('./styles')) {
        shelljs.rm('-rf', './styles');
    }
    var compName = JSON.parse(fs.readFileSync('./package.json', 'utf8')).name.replace('@syncfusion/ej2-', '');
    var themejson = require(__dirname + '/theme.json');
    if (themejson[compName]) {
        shelljs.mkdir('-p', './styles');
        shelljs.cp('-r', `./themestudio/styles/` + themejson[compName] + '/*', `./styles`);
        done();
    }
}
});

function themecheckout (done) {
    var user = 'SyncfusionBuild';
    var token = process.env.GithubBuildAutomation_PrivateToken;
    var branchName = 'development';
        themeclone(user, token, done, 'ej2-theme-studio', branchName);
}

function themeclone(user, token, done, name, branchName) {
    var shelljs = global.shelljs = global.shelljs || require('shelljs');
 //   token = token.replace('@', '%40');
    var tempRepo = 'https://' + user + ':' + token + '@github.com/essential-studio/' + name + ' -b ' + branchName;
    if(!token || token === '') {
        tempRepo = 'https://github.com/essential-studio/' + name + ' -b ' + branchName;
    }
    shelljs.exec(
        'git clone ' + tempRepo + ' ./themestudio', {
        silent: false
    },
    function () {
        console.log('Clone has been completed from ' + branchName + ' branch!');
        done();
    }
    );
}
function customizeTask() {
    var customPath = ['tailwind.css', 'tailwind-dark.css', 'material.css', 'material-dark.css'];
    for (var i = 0; i < customPath.length; i++) {

        var content = fs.readFileSync('./styles/' + customPath[i], 'utf-8');
        if (customPath[i] === 'tailwind.css' || customPath[i] === 'tailwind-dark.css') {
            content = content.replace('@import url("https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap");', '');
        }
        else {
            content = content.replace('@import url("https://fonts.googleapis.com/css?family=Roboto:400,500");', '');
        }

        fs.writeFileSync('./styles/customize/' + customPath[i], content);

    }
}

